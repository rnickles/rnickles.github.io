---
layout: default
title: Home
---
<h1>{{ "Hello World!" | downcase }}</h1>

<script>
    class Wall {
        #bod
        constructor(x, y, width, height, engine, group) {
            // matter stuff
            // create a matter body
            let bod = Matter.Bodies.rectangle(x, y, width, height, { isStatic: true });
            // add it to the physics world
            Matter.Composite.add(engine.world, bod)

            // THREE stuff
            // create a THREE geometry
            let geometry = new THREE.BoxGeometry(width, height - 30, 300); //hack to prevent overlap
            // create a THREE material
            let material = new THREE.MeshPhongMaterial({ color: 0x276a4b });
            // create a THREE mesh
            let mesh = new THREE.Mesh(geometry, material);
            // add the mesh to the scengraph group
            group.add(mesh)

            // align the mesh to the body
            mesh.position.set(x, y);

            // keep an instance variable
            this.#bod = bod;
        }

        // getter to access read-only private instance variable
        get bod() {
            return this.#bod;
        }

        render() {
            // update the position of the render to the physics engine
            // since it is a static body this function does nothing
        }
    }

    class Goal extends Wall {
        #detector
        constructor(x, y, engine, group, marble) {
            super(x, y, 200, 100, engine, group);
            this.#detector = Matter.Detector.create({ bodies: [this.bod, marble] });
        }

        render() {
            if (Matter.Detector.collisions(this.#detector).length !== 0) {
                console.log("winner")
            }
        }

    }
    const DOT_SIZE = 30;

    class Marble {
        #bod;
        #mesh;
        constructor(x, y, engine, group) {
            // matter stuff
            // create a matter body
            let bod = Matter.Bodies.circle(x, y, DOT_SIZE * 0.5, {
                friction: 0.00001,
                restitution: 0.5,
                density: 0.1
            });
            // add it to the physics world
            Matter.Composite.add(engine.world, bod);

            // THREE stuff
            // create a THREE geometry
            let geometry = new THREE.SphereGeometry(30, 16, 16);
            // create a THREE material
            let material = new THREE.MeshPhongMaterial({ color: 0x808080 });
            // create a THREE mesh
            let mesh = new THREE.Mesh(geometry, material);
            // add the mesh to the scengraph group
            group.add(mesh);

            // set instance variables
            this.#bod = bod;
            this.#mesh = mesh;
        }

        render() {
            // update the position of the render to the physics engine
            let pos = this.#bod.position;
            this.#mesh.position.set(pos.x, pos.y, 0)
        }
    }
    function init_level(engine, scene) {
        // create a group
        let group = new THREE.Object3D();
        // add the group to the scene
        scene.add(group);

        // the list of bodies in the level to be returned
        let _bodies = [];

        // create a wall that belongs to the group
        let _w = new Wall(0, 610, 1000, 100, engine, group);
        // add it to _bodies
        _bodies.push(_w);

        // create a wall that belongs to the group
        let _w2 = new Wall(0, -600, 1000, 100, engine, group);
        // add it to _bodies
        _bodies.push(_w2);

        // create a marble that drops onto the ground
        let _m = new Marble(0, 600, engine, group);
        // add it to _bodies
        _bodies.push(_m);

        let _g = new Goal(0, 0, engine, group, _m);
        _bodies.push(_w);

        return _bodies
    }

    function init() {

        // establish the renderer
        let renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // setup the camera and position slightly up and far back
        let camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.x = 0;
        camera.position.y = 200;
        camera.position.z = 1600;

        // setup the camera controls to accept input from a mouse or touch
        THREE.MOUSE.PAN = 0; // set pan to the left click
        THREE.MOUSE.ROTATE = 2;
        // const controls = new TrackballControls(camera, renderer.domElement);
        // controls.noRotate = true; // we don't want rotation

        // create a scene-graph data structure
        let scene = new THREE.Scene();

        // create a Matter.js engine
        let engine = Matter.Engine.create({
            gravity: { y: -1, scale: 0.005 }
        });

        // initialize the level and retrieve a list of game objects
        let _bodies = init_level(engine, scene);

        // run the physics engine
        Matter.Runner.run(engine);

        // lighting
        let dirLight1 = new THREE.DirectionalLight(0xffffff, 1);
        dirLight1.position.set(-30, 50, 40);
        scene.add(dirLight1);
        let dirLight2 = new THREE.DirectionalLight(0xffffff, 1);
        dirLight2.position.set(30, -50, -40);
        scene.add(dirLight2);

        //
        // THE GAME LOOP
        //
        function render() {

            requestAnimationFrame(render);

            // sychronize the rendered representation with the physical representation.
            for (let j = 0; j < _bodies.length; j++) {
                _bodies[j].render()
            }

            // update any changes to the view based on user input from either mouse or touch.
            // controls.update();

            // update the screen
            renderer.render(scene, camera);
        }

        render();
    }
    // schedule to call init() once the page loads.
    window.addEventListener('load', init);
</script>